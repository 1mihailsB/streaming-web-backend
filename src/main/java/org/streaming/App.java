/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package org.streaming;

import java.io.IOException;
import java.net.InetSocketAddress;
import java.net.StandardSocketOptions;
import java.nio.ByteBuffer;
import java.nio.channels.SelectionKey;
import java.nio.channels.ServerSocketChannel;
import java.nio.channels.SocketChannel;
import java.nio.channels.spi.SelectorProvider;

public class App {
    private static final int PORT = 5555;
    private static final ByteBuffer readBuffer = ByteBuffer.allocate(4096);

    public static void main(String[] args) throws IOException {
        var serverSocketChannel = ServerSocketChannel.open();
        serverSocketChannel.configureBlocking(false);

        // bind to local port
        var isa = new InetSocketAddress("localhost", PORT);
        serverSocketChannel.socket().bind(isa);
        // selectors
        var serverSelector = SelectorProvider.provider().openSelector();
        serverSocketChannel.register(serverSelector, SelectionKey.OP_ACCEPT);

        // Examples: sun/net/httpserver/ServerImpl.java:509

        while (true) {
            /**
             * TODO: select() has overload with msTimeout param that will return after given timeout.
             * If sockets didn't get any data during that time - we can close them if we want.
             */
            serverSelector.select();
            System.out.println("After select ---------");
            var selectedKeys = serverSelector.selectedKeys().iterator();
            while (selectedKeys.hasNext()) {
                System.out.println("while hasnext ---------");
                var key = selectedKeys.next();
                selectedKeys.remove();
                if (!key.isValid()) {
                    System.out.println("Key invalid: " + key);
                }

                if (key.channel().equals(serverSocketChannel)) { // or `key.isAcceptable()`
                    System.out.println("Acceptable");
                    var socketChannel = serverSocketChannel.accept(); // new connection from client
                    socketChannel.configureBlocking(false);
                    socketChannel.setOption(StandardSocketOptions.SO_KEEPALIVE, true);
                    socketChannel.setOption(StandardSocketOptions.TCP_NODELAY, true);
                    socketChannel.setOption(StandardSocketOptions.SO_REUSEADDR, true);
//                    int interest = SelectionKey.OP_READ | SelectionKey.OP_WRITE;
                    int interest = SelectionKey.OP_READ;
                    socketChannel.register(serverSelector, interest);
                } else if (key.isReadable()) {
                    System.out.println("Readable");
                    int read = ((SocketChannel) key.channel()).read(readBuffer.clear());  // incoming data on existing connection

                    if (read == -1) {
                        System.out.println("Buffer read -1");
                        key.channel().close();
                    } else {
                        var bytes = new byte[read];
                        readBuffer.get(0, bytes);
                        System.out.println(String.format(
                                        "Data from client key:\n%s:\n----------------------------------------\n%s",
                                        key,
                                        new String(bytes)
                                )
                        );

                        String html = "<html><body>Custom html response</body></html>";
                        final String CRLF = "\n\r"; // 13, 10
                        String response =
                                "HTTP/2.0 200 OK" + CRLF
                                        + "Content-Length: " + html.getBytes().length + CRLF
                                        + CRLF
                                        + html
                                        + CRLF + CRLF;

//                        ((SocketChannel) key.channel()).write(ByteBuffer.wrap(bytes));
                        ((SocketChannel) key.channel()).write(ByteBuffer.wrap(response.getBytes()));
                    }
                }
            }
        }
    }
}